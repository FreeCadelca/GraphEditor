<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GraphEditor: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom_styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GraphEditor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Класс, представляющий граф и реализующий основные алгоритмы работы с графами.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_graph_1_1_edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Структура для представления ребра.  <a href="struct_graph_1_1_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a18a8b6f93b9324aebbb91c717d4e8a2c" id="r_a18a8b6f93b9324aebbb91c717d4e8a2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18a8b6f93b9324aebbb91c717d4e8a2c">addVertex</a> (double x, double y)</td></tr>
<tr class="memdesc:a18a8b6f93b9324aebbb91c717d4e8a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавление вершины в граф.  <br /></td></tr>
<tr class="separator:a18a8b6f93b9324aebbb91c717d4e8a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37366bd54911b7f2c1d36454676100eb" id="r_a37366bd54911b7f2c1d36454676100eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37366bd54911b7f2c1d36454676100eb">addEdge</a> (char v_from, char v_to, int weight=-1000000000)</td></tr>
<tr class="memdesc:a37366bd54911b7f2c1d36454676100eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Добавление ребра в граф.  <br /></td></tr>
<tr class="separator:a37366bd54911b7f2c1d36454676100eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3756b3f119464ca5fa8e7e77b14def9b" id="r_a3756b3f119464ca5fa8e7e77b14def9b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3756b3f119464ca5fa8e7e77b14def9b">getPrintoutAdjList</a> ()</td></tr>
<tr class="memdesc:a3756b3f119464ca5fa8e7e77b14def9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение строки, представляющей список смежности графа.  <br /></td></tr>
<tr class="separator:a3756b3f119464ca5fa8e7e77b14def9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6e934c2461e3dc482616caeccc06da" id="r_a2c6e934c2461e3dc482616caeccc06da"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c6e934c2461e3dc482616caeccc06da">getPrintoutAdjMatrix</a> ()</td></tr>
<tr class="memdesc:a2c6e934c2461e3dc482616caeccc06da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение строки, представляющей матрицу смежности графа.  <br /></td></tr>
<tr class="separator:a2c6e934c2461e3dc482616caeccc06da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648b52bc823140da4a8c8c89d5e8e1ac" id="r_a648b52bc823140da4a8c8c89d5e8e1ac"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a648b52bc823140da4a8c8c89d5e8e1ac">getPrintoutAlgorithm</a> ()</td></tr>
<tr class="memdesc:a648b52bc823140da4a8c8c89d5e8e1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение строки, представляющей результат выполнения алгоритма.  <br /></td></tr>
<tr class="separator:a648b52bc823140da4a8c8c89d5e8e1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda7d03cd8f8d6b9d5440f761137e9ea" id="r_adda7d03cd8f8d6b9d5440f761137e9ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adda7d03cd8f8d6b9d5440f761137e9ea">runAlgorithm</a> (const std::string &amp;algorithm, char start_vertex='\n', char end_vertex='\n')</td></tr>
<tr class="memdesc:adda7d03cd8f8d6b9d5440f761137e9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Выполнение указанного алгоритма.  <br /></td></tr>
<tr class="separator:adda7d03cd8f8d6b9d5440f761137e9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab3a1b6c8ee07002735e989f7abaa8106" id="r_ab3a1b6c8ee07002735e989f7abaa8106"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_graph.html">Graph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3a1b6c8ee07002735e989f7abaa8106">getInstance</a> ()</td></tr>
<tr class="memdesc:ab3a1b6c8ee07002735e989f7abaa8106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение единственного экземпляра класса <a class="el" href="class_graph.html" title="Класс, представляющий граф и реализующий основные алгоритмы работы с графами.">Graph</a>.  <br /></td></tr>
<tr class="separator:ab3a1b6c8ee07002735e989f7abaa8106"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a83c213617bc448b021fcb3b7644a0969" id="r_a83c213617bc448b021fcb3b7644a0969"><td class="memItemLeft" align="right" valign="top">std::map&lt; char, std::vector&lt; char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83c213617bc448b021fcb3b7644a0969">adjacent_list</a></td></tr>
<tr class="memdesc:a83c213617bc448b021fcb3b7644a0969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Список смежности  <br /></td></tr>
<tr class="separator:a83c213617bc448b021fcb3b7644a0969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4755d1464ab2f02b8760d870e724743" id="r_ac4755d1464ab2f02b8760d870e724743"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4755d1464ab2f02b8760d870e724743">adjacent_matrix</a></td></tr>
<tr class="memdesc:ac4755d1464ab2f02b8760d870e724743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Матрица смежности  <br /></td></tr>
<tr class="separator:ac4755d1464ab2f02b8760d870e724743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a582524d63df99928e6b1feee31a24" id="r_a10a582524d63df99928e6b1feee31a24"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10a582524d63df99928e6b1feee31a24">TITLES</a> = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</td></tr>
<tr class="memdesc:a10a582524d63df99928e6b1feee31a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Названия вершин  <br /></td></tr>
<tr class="separator:a10a582524d63df99928e6b1feee31a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc3eaf4b4f0a0c4becde65bd7b76bd8" id="r_a3fc3eaf4b4f0a0c4becde65bd7b76bd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fc3eaf4b4f0a0c4becde65bd7b76bd8">ID_NEXT_TITLE</a> = 0</td></tr>
<tr class="memdesc:a3fc3eaf4b4f0a0c4becde65bd7b76bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Номер следующей вершины для выбора  <br /></td></tr>
<tr class="separator:a3fc3eaf4b4f0a0c4becde65bd7b76bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68773809bb43852a6dd4aaac15b6eea9" id="r_a68773809bb43852a6dd4aaac15b6eea9"><td class="memItemLeft" align="right" valign="top">std::map&lt; char, std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68773809bb43852a6dd4aaac15b6eea9">coords</a></td></tr>
<tr class="memdesc:a68773809bb43852a6dd4aaac15b6eea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Координаты вершин  <br /></td></tr>
<tr class="separator:a68773809bb43852a6dd4aaac15b6eea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd0824db923712f473603157339b97e" id="r_aecd0824db923712f473603157339b97e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecd0824db923712f473603157339b97e">nextWeight</a> = 1</td></tr>
<tr class="memdesc:aecd0824db923712f473603157339b97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вес следующего ребра  <br /></td></tr>
<tr class="separator:aecd0824db923712f473603157339b97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae4c72b8ac4d693c49800a4c7e273654f" id="r_ae4c72b8ac4d693c49800a4c7e273654f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4c72b8ac4d693c49800a4c7e273654f">Graph</a> ()</td></tr>
<tr class="memdesc:ae4c72b8ac4d693c49800a4c7e273654f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Приватный конструктор для реализации singleton.  <br /></td></tr>
<tr class="separator:ae4c72b8ac4d693c49800a4c7e273654f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed06ed279b3734d37dbcff5430ea36d1" id="r_aed06ed279b3734d37dbcff5430ea36d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed06ed279b3734d37dbcff5430ea36d1">run_bfs</a> (char start_vertex)</td></tr>
<tr class="memdesc:aed06ed279b3734d37dbcff5430ea36d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Запуск алгоритма обхода графа в ширину (BFS) с заданной стартовой вершины.  <br /></td></tr>
<tr class="separator:aed06ed279b3734d37dbcff5430ea36d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643449e5fcf9b44db0fa375c5f3fe27a" id="r_a643449e5fcf9b44db0fa375c5f3fe27a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a643449e5fcf9b44db0fa375c5f3fe27a">run_dfs</a> (char start_vertex)</td></tr>
<tr class="memdesc:a643449e5fcf9b44db0fa375c5f3fe27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Запуск алгоритма обхода графа в глубину (DFS) с заданной стартовой вершины.  <br /></td></tr>
<tr class="separator:a643449e5fcf9b44db0fa375c5f3fe27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd9e0ad6a6062af366e5fd2a1b20402" id="r_afdd9e0ad6a6062af366e5fd2a1b20402"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdd9e0ad6a6062af366e5fd2a1b20402">dijkstra</a> (char start_vertex, char end_vertex='\n')</td></tr>
<tr class="memdesc:afdd9e0ad6a6062af366e5fd2a1b20402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Запуск алгоритма Дейкстры для поиска кратчайшего пути в графе.  <br /></td></tr>
<tr class="separator:afdd9e0ad6a6062af366e5fd2a1b20402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601f5935c1e655b57f8376b36884cdcb" id="r_a601f5935c1e655b57f8376b36884cdcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a601f5935c1e655b57f8376b36884cdcb">bellman_ford</a> (char start_vertex, char end_vertex='\n')</td></tr>
<tr class="memdesc:a601f5935c1e655b57f8376b36884cdcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Запуск алгоритма Беллмана-Форда для поиска кратчайших путей в графе.  <br /></td></tr>
<tr class="separator:a601f5935c1e655b57f8376b36884cdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de36bcb031663da79fc00f5aa0eaede" id="r_a1de36bcb031663da79fc00f5aa0eaede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1de36bcb031663da79fc00f5aa0eaede">kruskal</a> ()</td></tr>
<tr class="memdesc:a1de36bcb031663da79fc00f5aa0eaede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Реализация алгоритма Краскала для поиска минимального остовного дерева в графе.  <br /></td></tr>
<tr class="separator:a1de36bcb031663da79fc00f5aa0eaede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3da3461fb89b317e0385aed2bb6cfda" id="r_ad3da3461fb89b317e0385aed2bb6cfda"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3da3461fb89b317e0385aed2bb6cfda">find</a> (std::map&lt; char, char &gt; &amp;parent, char vertex)</td></tr>
<tr class="memdesc:ad3da3461fb89b317e0385aed2bb6cfda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вспомогательная функция для поиска корневой вершины дерева в структуре данных "дискретные множества".  <br /></td></tr>
<tr class="separator:ad3da3461fb89b317e0385aed2bb6cfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5b0e175d30fd3d24ff37773d12b077" id="r_a7a5b0e175d30fd3d24ff37773d12b077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a5b0e175d30fd3d24ff37773d12b077">union_sets</a> (std::map&lt; char, char &gt; &amp;parent, char u, char v)</td></tr>
<tr class="memdesc:a7a5b0e175d30fd3d24ff37773d12b077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вспомогательная функция для объединения двух деревьев в структуре данных "дискретные множества".  <br /></td></tr>
<tr class="separator:a7a5b0e175d30fd3d24ff37773d12b077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb18a1f9d2ad51214d4211d60edf6860" id="r_acb18a1f9d2ad51214d4211d60edf6860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb18a1f9d2ad51214d4211d60edf6860">prim</a> ()</td></tr>
<tr class="memdesc:acb18a1f9d2ad51214d4211d60edf6860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Реализация алгоритма Прима для поиска минимального остовного дерева в графе.  <br /></td></tr>
<tr class="separator:acb18a1f9d2ad51214d4211d60edf6860"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a062427bc763104537a8b461737acc9bd" id="r_a062427bc763104537a8b461737acc9bd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a062427bc763104537a8b461737acc9bd">printoutAlgorithm</a></td></tr>
<tr class="memdesc:a062427bc763104537a8b461737acc9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Строка для вывода результатов алгоритмов  <br /></td></tr>
<tr class="separator:a062427bc763104537a8b461737acc9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aabdb84dfb6a0985f453cc3da65ba2770" id="r_aabdb84dfb6a0985f453cc3da65ba2770"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_graph.html">Graph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabdb84dfb6a0985f453cc3da65ba2770">instance</a> = nullptr</td></tr>
<tr class="memdesc:aabdb84dfb6a0985f453cc3da65ba2770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Указатель на единственный экземпляр класса (singleton)  <br /></td></tr>
<tr class="separator:aabdb84dfb6a0985f453cc3da65ba2770"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a758b2efa0ca767374ea2157d8d76fc65" id="r_a758b2efa0ca767374ea2157d8d76fc65"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a758b2efa0ca767374ea2157d8d76fc65">GraphTestSuite</a></td></tr>
<tr class="separator:a758b2efa0ca767374ea2157d8d76fc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8eacc7949c8a7fe17497370f0f4586" id="r_a2d8eacc7949c8a7fe17497370f0f4586"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d8eacc7949c8a7fe17497370f0f4586">GraphTestAccessor</a></td></tr>
<tr class="separator:a2d8eacc7949c8a7fe17497370f0f4586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144ebc130cd6e4b1e2546fc33e8a8d45" id="r_a144ebc130cd6e4b1e2546fc33e8a8d45"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a144ebc130cd6e4b1e2546fc33e8a8d45">AppTestSuite</a></td></tr>
<tr class="separator:a144ebc130cd6e4b1e2546fc33e8a8d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Класс, представляющий граф и реализующий основные алгоритмы работы с графами. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae4c72b8ac4d693c49800a4c7e273654f" name="ae4c72b8ac4d693c49800a4c7e273654f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c72b8ac4d693c49800a4c7e273654f">&#9670;&#160;</a></span>Graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Приватный конструктор для реализации singleton. </p>
<p>Конструктор класса <a class="el" href="class_graph.html" title="Класс, представляющий граф и реализующий основные алгоритмы работы с графами.">Graph</a>. Конструктор по умолчанию. Создает пустой граф. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a37366bd54911b7f2c1d36454676100eb" name="a37366bd54911b7f2c1d36454676100eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37366bd54911b7f2c1d36454676100eb">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>v_from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>v_to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1000000000</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Добавление ребра в граф. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v_from</td><td>Вершина, из которой исходит ребро </td></tr>
    <tr><td class="paramname">v_to</td><td>Вершина, в которую входит ребро </td></tr>
    <tr><td class="paramname">weight</td><td>Вес ребра (по умолчанию -1000000000)</td></tr>
    <tr><td class="paramname">v_from</td><td>Вершина, из которой выходит ребро. </td></tr>
    <tr><td class="paramname">v_to</td><td>Вершина, в которую входит ребро. </td></tr>
    <tr><td class="paramname">weight</td><td>Вес ребра. Если значение веса равно -1000000000, используется значение nextWeight.</td></tr>
  </table>
  </dd>
</dl>
<p>Метод добавляет ребро между двумя вершинами в списке смежности и обновляет матрицу смежности. После добавления ребра граф перерисовывается. </p>

</div>
</div>
<a id="a18a8b6f93b9324aebbb91c717d4e8a2c" name="a18a8b6f93b9324aebbb91c717d4e8a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a8b6f93b9324aebbb91c717d4e8a2c">&#9670;&#160;</a></span>addVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addVertex </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Добавление вершины в граф. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Координата x вершины </td></tr>
    <tr><td class="paramname">y</td><td>Координата y вершины</td></tr>
    <tr><td class="paramname">x</td><td>Координата x вершины. </td></tr>
    <tr><td class="paramname">y</td><td>Координата y вершины.</td></tr>
  </table>
  </dd>
</dl>
<p>Метод добавляет новую вершину в граф с указанными координатами. Вершина также добавляется в список смежности и матрицу смежности. После добавления вершины граф перерисовывается. </p>

</div>
</div>
<a id="a601f5935c1e655b57f8376b36884cdcb" name="a601f5935c1e655b57f8376b36884cdcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601f5935c1e655b57f8376b36884cdcb">&#9670;&#160;</a></span>bellman_ford()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::bellman_ford </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>start_vertex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>end_vertex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'\n'</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Запуск алгоритма Беллмана-Форда для поиска кратчайших путей в графе. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_vertex</td><td>Символ, обозначающий начальную вершину. </td></tr>
    <tr><td class="paramname">end_vertex</td><td>Символ, обозначающий конечную вершину. Если end_vertex == '<br  />
', то считается, что конечная вершина не задана.</td></tr>
  </table>
  </dd>
</dl>
<p>Алгоритм находит кратчайшие пути от начальной вершины до всех остальных вершин графа. Если граф пуст или содержит отрицательные циклы, устанавливается сообщение об ошибке. Результат работы алгоритма сохраняется в переменной printoutAlgorithm.</p>
<p>Алгоритм использует множества и словари для отслеживания посещенных вершин, предков и расстояний. Также выполняется анимация пути для визуализации результатов.</p>
<dl class="section user"><dt>Пример использования:</dt><dd><div class="fragment"><div class="line"><a class="code hl_function" href="#ab3a1b6c8ee07002735e989f7abaa8106">Graph::getInstance</a>()-&gt;<a class="code hl_function" href="#a601f5935c1e655b57f8376b36884cdcb">bellman_ford</a>(<span class="charliteral">&#39;A&#39;</span>, <span class="charliteral">&#39;D&#39;</span>);</div>
<div class="line">std::string result = <a class="code hl_function" href="#ab3a1b6c8ee07002735e989f7abaa8106">Graph::getInstance</a>()-&gt;<a class="code hl_function" href="#a648b52bc823140da4a8c8c89d5e8e1ac">getPrintoutAlgorithm</a>();</div>
<div class="line">std::cout &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="ttc" id="aclass_graph_html_a601f5935c1e655b57f8376b36884cdcb"><div class="ttname"><a href="#a601f5935c1e655b57f8376b36884cdcb">Graph::bellman_ford</a></div><div class="ttdeci">void bellman_ford(char start_vertex, char end_vertex='\n')</div><div class="ttdoc">Запуск алгоритма Беллмана-Форда для поиска кратчайших путей в графе.</div><div class="ttdef"><b>Definition</b> Graph.cpp:566</div></div>
<div class="ttc" id="aclass_graph_html_a648b52bc823140da4a8c8c89d5e8e1ac"><div class="ttname"><a href="#a648b52bc823140da4a8c8c89d5e8e1ac">Graph::getPrintoutAlgorithm</a></div><div class="ttdeci">std::string getPrintoutAlgorithm()</div><div class="ttdoc">Получение строки, представляющей результат выполнения алгоритма.</div><div class="ttdef"><b>Definition</b> Graph.cpp:171</div></div>
<div class="ttc" id="aclass_graph_html_ab3a1b6c8ee07002735e989f7abaa8106"><div class="ttname"><a href="#ab3a1b6c8ee07002735e989f7abaa8106">Graph::getInstance</a></div><div class="ttdeci">static Graph * getInstance()</div><div class="ttdoc">Получение единственного экземпляра класса Graph.</div><div class="ttdef"><b>Definition</b> Graph.cpp:29</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a648b52bc823140da4a8c8c89d5e8e1ac" title="Получение строки, представляющей результат выполнения алгоритма.">getPrintoutAlgorithm()</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Убедитесь, что объект <a class="el" href="class_canvas.html" title="Класс, реализующий графическое представление графа и анимации алгоритмов.">Canvas</a> создан и инициализирован перед вызовом метода. </dd></dl>
<p>акназар</p>

</div>
</div>
<a id="afdd9e0ad6a6062af366e5fd2a1b20402" name="afdd9e0ad6a6062af366e5fd2a1b20402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd9e0ad6a6062af366e5fd2a1b20402">&#9670;&#160;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dijkstra </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>start_vertex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>end_vertex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'\n'</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Запуск алгоритма Дейкстры для поиска кратчайшего пути в графе. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_vertex</td><td>Символ, обозначающий начальную вершину. </td></tr>
    <tr><td class="paramname">end_vertex</td><td>Символ, обозначающий конечную вершину. Если end_vertex == '<br  />
', то считается, что конечная вершина не задана.</td></tr>
  </table>
  </dd>
</dl>
<p>Алгоритм находит кратчайшие пути от начальной вершины до всех остальных вершин графа. Если граф пуст или содержит отрицательные циклы, устанавливается сообщение об ошибке. Результат работы алгоритма сохраняется в переменной printoutAlgorithm.</p>
<p>Алгоритм использует множества и словари для отслеживания посещенных вершин, предков и расстояний. Также выполняется анимация пути для визуализации результатов.</p>
<dl class="section user"><dt>Пример использования:</dt><dd><div class="fragment"><div class="line"><a class="code hl_function" href="#ab3a1b6c8ee07002735e989f7abaa8106">Graph::getInstance</a>()-&gt;<a class="code hl_function" href="#afdd9e0ad6a6062af366e5fd2a1b20402">dijkstra</a>(<span class="charliteral">&#39;A&#39;</span>, <span class="charliteral">&#39;D&#39;</span>);</div>
<div class="line">std::string result = <a class="code hl_function" href="#ab3a1b6c8ee07002735e989f7abaa8106">Graph::getInstance</a>()-&gt;<a class="code hl_function" href="#a648b52bc823140da4a8c8c89d5e8e1ac">getPrintoutAlgorithm</a>();</div>
<div class="line">std::cout &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="ttc" id="aclass_graph_html_afdd9e0ad6a6062af366e5fd2a1b20402"><div class="ttname"><a href="#afdd9e0ad6a6062af366e5fd2a1b20402">Graph::dijkstra</a></div><div class="ttdeci">void dijkstra(char start_vertex, char end_vertex='\n')</div><div class="ttdoc">Запуск алгоритма Дейкстры для поиска кратчайшего пути в графе.</div><div class="ttdef"><b>Definition</b> Graph.cpp:409</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a648b52bc823140da4a8c8c89d5e8e1ac" title="Получение строки, представляющей результат выполнения алгоритма.">getPrintoutAlgorithm()</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Убедитесь, что объект <a class="el" href="class_canvas.html" title="Класс, реализующий графическое представление графа и анимации алгоритмов.">Canvas</a> создан и инициализирован перед вызовом метода. </dd></dl>

</div>
</div>
<a id="ad3da3461fb89b317e0385aed2bb6cfda" name="ad3da3461fb89b317e0385aed2bb6cfda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3da3461fb89b317e0385aed2bb6cfda">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char Graph::find </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; char, char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>vertex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Вспомогательная функция для поиска корневой вершины дерева в структуре данных "дискретные множества". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Ссылка на словарь, в котором ключи - вершины, а значения - их родители. </td></tr>
    <tr><td class="paramname">vertex</td><td>Вершина, для которой необходимо найти корневую вершину.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Символ, обозначающий корневую вершину.</dd></dl>
<p>Функция реализует операцию поиска с пути сжатия (path compression) для структуры данных "дискретные множества". Это позволяет эффективно находить корневую вершину для заданной вершины, оптимизируя дерево, что уменьшает время выполнения будущих операций. Если текущая вершина не является корнем, выполняется рекурсивный поиск до корневой вершины, при этом применяется сжатие пути для всех промежуточных вершин.</p>
<dl class="section user"><dt>Пример использования:</dt><dd><div class="fragment"><div class="line">std::map&lt;char, char&gt; parent;</div>
<div class="line">parent[<span class="charliteral">&#39;A&#39;</span>] = <span class="charliteral">&#39;A&#39;</span>;</div>
<div class="line">parent[<span class="charliteral">&#39;B&#39;</span>] = <span class="charliteral">&#39;A&#39;</span>;</div>
<div class="line"><span class="keywordtype">char</span> root = <a class="code hl_function" href="#ad3da3461fb89b317e0385aed2bb6cfda">find</a>(parent, <span class="charliteral">&#39;B&#39;</span>); <span class="comment">// Вернёт &#39;A&#39;</span></div>
<div class="ttc" id="aclass_graph_html_ad3da3461fb89b317e0385aed2bb6cfda"><div class="ttname"><a href="#ad3da3461fb89b317e0385aed2bb6cfda">Graph::find</a></div><div class="ttdeci">char find(std::map&lt; char, char &gt; &amp;parent, char vertex)</div><div class="ttdoc">Вспомогательная функция для поиска корневой вершины дерева в структуре данных &quot;дискретные множества&quot;.</div><div class="ttdef"><b>Definition</b> Graph.cpp:705</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd>union() </dd></dl>

</div>
</div>
<a id="ab3a1b6c8ee07002735e989f7abaa8106" name="ab3a1b6c8ee07002735e989f7abaa8106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a1b6c8ee07002735e989f7abaa8106">&#9670;&#160;</a></span>getInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> * Graph::getInstance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получение единственного экземпляра класса <a class="el" href="class_graph.html" title="Класс, представляющий граф и реализующий основные алгоритмы работы с графами.">Graph</a>. </p>
<p>Получение единственного экземпляра графа (Singleton).</p>
<dl class="section return"><dt>Returns</dt><dd>Указатель на единственный экземпляр класса <a class="el" href="class_graph.html" title="Класс, представляющий граф и реализующий основные алгоритмы работы с графами.">Graph</a>.</dd>
<dd>
Указатель на единственный экземпляр графа.</dd></dl>
<p>Метод реализует паттерн проектирования Singleton. Если экземпляр графа еще не создан, он создает новый экземпляр. В противном случае возвращает указатель на уже существующий экземпляр. </p>

</div>
</div>
<a id="a3756b3f119464ca5fa8e7e77b14def9b" name="a3756b3f119464ca5fa8e7e77b14def9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3756b3f119464ca5fa8e7e77b14def9b">&#9670;&#160;</a></span>getPrintoutAdjList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Graph::getPrintoutAdjList </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение строки, представляющей список смежности графа. </p>
<p>Получение строкового представления списка смежности графа.</p>
<dl class="section return"><dt>Returns</dt><dd>Строка, представляющая список смежности графа.</dd>
<dd>
Строковое представление списка смежности графа.</dd></dl>
<p>Метод формирует и возвращает строку, представляющую список смежности графа. Каждая вершина представлена на отдельной строке в формате "Вершина: Смежные вершины". Если у вершины нет смежных вершин, добавляется "None". </p>

</div>
</div>
<a id="a2c6e934c2461e3dc482616caeccc06da" name="a2c6e934c2461e3dc482616caeccc06da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6e934c2461e3dc482616caeccc06da">&#9670;&#160;</a></span>getPrintoutAdjMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Graph::getPrintoutAdjMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение строки, представляющей матрицу смежности графа. </p>
<p>Получение строкового представления матрицы смежности графа.</p>
<dl class="section return"><dt>Returns</dt><dd>Строка, представляющая матрицу смежности графа.</dd>
<dd>
Строковое представление матрицы смежности графа.</dd></dl>
<p>Метод формирует и возвращает строку, представляющую матрицу смежности графа. Первая строка содержит заголовки столбцов, соответствующие вершинам графа. Далее для каждой вершины графа добавляется строка, начинающаяся с обозначения вершины, за которой следуют значения смежности с другими вершинами, разделённые пробелами. </p>

</div>
</div>
<a id="a648b52bc823140da4a8c8c89d5e8e1ac" name="a648b52bc823140da4a8c8c89d5e8e1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648b52bc823140da4a8c8c89d5e8e1ac">&#9670;&#160;</a></span>getPrintoutAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Graph::getPrintoutAlgorithm </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение строки, представляющей результат выполнения алгоритма. </p>
<p>Получение результата последнего запущенного алгоритма.</p>
<dl class="section return"><dt>Returns</dt><dd>Строка, представляющая результат выполнения алгоритма.</dd>
<dd>
Строковое представление результата последнего запущенного алгоритма.</dd></dl>
<p>Метод возвращает строку, содержащую результат последнего выполненного алгоритма, хранящуюся в переменной printoutAlgorithm. </p>

</div>
</div>
<a id="a1de36bcb031663da79fc00f5aa0eaede" name="a1de36bcb031663da79fc00f5aa0eaede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de36bcb031663da79fc00f5aa0eaede">&#9670;&#160;</a></span>kruskal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::kruskal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Реализация алгоритма Краскала для поиска минимального остовного дерева в графе. </p>
<p>Алгоритм Краскала находит минимальное остовное дерево (МСТ) графа, сортируя все рёбра по весу и добавляя их в дерево, если они не образуют цикл. Для этого используется структура данных "дискретные множества".</p>
<p>Если граф пуст или содержит только одну вершину, устанавливается сообщение об ошибке. Результат работы алгоритма сохраняется в переменной printoutAlgorithm.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad3da3461fb89b317e0385aed2bb6cfda" title="Вспомогательная функция для поиска корневой вершины дерева в структуре данных &quot;дискретные множества&quot;.">find()</a>, <a class="el" href="#a7a5b0e175d30fd3d24ff37773d12b077" title="Вспомогательная функция для объединения двух деревьев в структуре данных &quot;дискретные множества&quot;.">union_sets()</a> </dd></dl>

</div>
</div>
<a id="acb18a1f9d2ad51214d4211d60edf6860" name="acb18a1f9d2ad51214d4211d60edf6860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb18a1f9d2ad51214d4211d60edf6860">&#9670;&#160;</a></span>prim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::prim </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Реализация алгоритма Прима для поиска минимального остовного дерева в графе. </p>
<p>Алгоритм Прима находит минимальное остовное дерево (МСТ) графа, начиная с произвольной стартовой вершины, добавляя рёбра минимального веса, которые соединяют посещённые и непосещённые вершины.</p>
<p>Если граф пуст или содержит только одну вершину, устанавливается сообщение об ошибке. Результат работы алгоритма сохраняется в переменной printoutAlgorithm. </p>

</div>
</div>
<a id="aed06ed279b3734d37dbcff5430ea36d1" name="aed06ed279b3734d37dbcff5430ea36d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed06ed279b3734d37dbcff5430ea36d1">&#9670;&#160;</a></span>run_bfs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::run_bfs </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>start_vertex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Запуск алгоритма обхода графа в ширину (BFS) с заданной стартовой вершины. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_vertex</td><td>Символ, обозначающий начальную вершину обхода.</td></tr>
  </table>
  </dd>
</dl>
<p>Метод выполняет обход графа в ширину (BFS), начиная с указанной стартовой вершины. Если граф пуст, устанавливается сообщение об ошибке. Результат обхода сохраняется в переменной printoutAlgorithm. Вершины, посещённые во время обхода, отображаются с задержкой для визуализации процесса.</p>
<dl class="section note"><dt>Note</dt><dd>Визуализация включает задержку между отображениями посещённых вершин.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Граф должен содержать хотя бы одну вершину и одно ребро для успешного выполнения.</dd></dl>
<dl class="section user"><dt>Пример использования:</dt><dd><div class="fragment"><div class="line"><a class="code hl_function" href="#ab3a1b6c8ee07002735e989f7abaa8106">Graph::getInstance</a>()-&gt;<a class="code hl_function" href="#aed06ed279b3734d37dbcff5430ea36d1">run_bfs</a>(<span class="charliteral">&#39;A&#39;</span>);</div>
<div class="line">std::string result = <a class="code hl_function" href="#ab3a1b6c8ee07002735e989f7abaa8106">Graph::getInstance</a>()-&gt;<a class="code hl_function" href="#a648b52bc823140da4a8c8c89d5e8e1ac">getPrintoutAlgorithm</a>();</div>
<div class="line">std::cout &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="ttc" id="aclass_graph_html_aed06ed279b3734d37dbcff5430ea36d1"><div class="ttname"><a href="#aed06ed279b3734d37dbcff5430ea36d1">Graph::run_bfs</a></div><div class="ttdeci">void run_bfs(char start_vertex)</div><div class="ttdoc">Запуск алгоритма обхода графа в ширину (BFS) с заданной стартовой вершины.</div><div class="ttdef"><b>Definition</b> Graph.cpp:227</div></div>
</div><!-- fragment --></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Если граф пуст.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a648b52bc823140da4a8c8c89d5e8e1ac" title="Получение строки, представляющей результат выполнения алгоритма.">getPrintoutAlgorithm()</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Визуализация требует наличия объекта <a class="el" href="class_canvas.html" title="Класс, реализующий графическое представление графа и анимации алгоритмов.">Canvas</a>.</dd></dl>
<p>Алгоритм работает следующим образом:</p><ol type="1">
<li>Проверяется наличие вершин и рёбер в графе.</li>
<li>Инициализируется очередь и множество посещённых вершин.</li>
<li>Выполняется обход графа в ширину, начиная с заданной вершины.</li>
<li>Для каждой посещённой вершины добавляется задержка для визуализации.</li>
<li>Результат обхода сохраняется в переменной printoutAlgorithm.</li>
</ol>
<dl class="section user"><dt>Заметки:</dt><dd><ul>
<li>Задержка между отрисовками вершин составляет 400 миллисекунд.</li>
<li>Используется класс <a class="el" href="class_canvas.html" title="Класс, реализующий графическое представление графа и анимации алгоритмов.">Canvas</a> для визуализации.</li>
</ul>
</dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug</a></b></dt><dd>Неизвестные проблемы отсутствуют.</dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000001">Test</a></b></dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Пример теста для проверки работы метода run_bfs</span></div>
<div class="line"><a class="code hl_function" href="#ab3a1b6c8ee07002735e989f7abaa8106">Graph::getInstance</a>()-&gt;<a class="code hl_function" href="#aed06ed279b3734d37dbcff5430ea36d1">run_bfs</a>(<span class="charliteral">&#39;A&#39;</span>);</div>
<div class="line">ASSERT_EQ(<a class="code hl_function" href="#ab3a1b6c8ee07002735e989f7abaa8106">Graph::getInstance</a>()-&gt;<a class="code hl_function" href="#a648b52bc823140da4a8c8c89d5e8e1ac">getPrintoutAlgorithm</a>(), expected_output);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Убедитесь, что объект <a class="el" href="class_canvas.html" title="Класс, реализующий графическое представление графа и анимации алгоритмов.">Canvas</a> создан и инициализирован перед вызовом метода.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Этот метод использует библиотеку Glib для таймеров задержки. </dd></dl>

</div>
</div>
<a id="a643449e5fcf9b44db0fa375c5f3fe27a" name="a643449e5fcf9b44db0fa375c5f3fe27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643449e5fcf9b44db0fa375c5f3fe27a">&#9670;&#160;</a></span>run_dfs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::run_dfs </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>start_vertex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Запуск алгоритма обхода графа в глубину (DFS) с заданной стартовой вершины. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_vertex</td><td>Символ, обозначающий начальную вершину обхода.</td></tr>
  </table>
  </dd>
</dl>
<p>Алгоритм выполняет обход графа в глубину (DFS), начиная с указанной стартовой вершины. Если граф пуст, устанавливается сообщение об ошибке. Результат обхода сохраняется в переменной printoutAlgorithm.</p>
<p>Алгоритм использует стек для отслеживания вершин, которые необходимо посетить, и множество для отслеживания посещенных вершин. Также выполняется анимация посещения вершин с задержкой.</p>
<dl class="section user"><dt>Пример использования:</dt><dd><div class="fragment"><div class="line"><a class="code hl_function" href="#ab3a1b6c8ee07002735e989f7abaa8106">Graph::getInstance</a>()-&gt;<a class="code hl_function" href="#a643449e5fcf9b44db0fa375c5f3fe27a">run_dfs</a>(<span class="charliteral">&#39;A&#39;</span>);</div>
<div class="line">std::string result = <a class="code hl_function" href="#ab3a1b6c8ee07002735e989f7abaa8106">Graph::getInstance</a>()-&gt;<a class="code hl_function" href="#a648b52bc823140da4a8c8c89d5e8e1ac">getPrintoutAlgorithm</a>();</div>
<div class="line">std::cout &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="ttc" id="aclass_graph_html_a643449e5fcf9b44db0fa375c5f3fe27a"><div class="ttname"><a href="#a643449e5fcf9b44db0fa375c5f3fe27a">Graph::run_dfs</a></div><div class="ttdeci">void run_dfs(char start_vertex)</div><div class="ttdoc">Запуск алгоритма обхода графа в глубину (DFS) с заданной стартовой вершины.</div><div class="ttdef"><b>Definition</b> Graph.cpp:317</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a648b52bc823140da4a8c8c89d5e8e1ac" title="Получение строки, представляющей результат выполнения алгоритма.">getPrintoutAlgorithm()</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Убедитесь, что объект <a class="el" href="class_canvas.html" title="Класс, реализующий графическое представление графа и анимации алгоритмов.">Canvas</a> создан и инициализирован перед вызовом метода. </dd></dl>

</div>
</div>
<a id="adda7d03cd8f8d6b9d5440f761137e9ea" name="adda7d03cd8f8d6b9d5440f761137e9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda7d03cd8f8d6b9d5440f761137e9ea">&#9670;&#160;</a></span>runAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::runAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>algorithm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>start_vertex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'\n'</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>end_vertex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'\n'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Выполнение указанного алгоритма. </p>
<p>Выполняет указанный алгоритм графа с заданными стартовой и конечной вершинами.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algorithm</td><td>Название алгоритма </td></tr>
    <tr><td class="paramname">start_vertex</td><td>Начальная вершина (по умолчанию '<br  />
') </td></tr>
    <tr><td class="paramname">end_vertex</td><td>Конечная вершина (по умолчанию '<br  />
')</td></tr>
    <tr><td class="paramname">algorithm</td><td>Название алгоритма для выполнения. </td></tr>
    <tr><td class="paramname">start_vertex</td><td>Стартовая вершина для выполнения алгоритма. </td></tr>
    <tr><td class="paramname">end_vertex</td><td>Конечная вершина для выполнения алгоритма (может не использоваться в некоторых алгоритмах). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a5b0e175d30fd3d24ff37773d12b077" name="a7a5b0e175d30fd3d24ff37773d12b077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5b0e175d30fd3d24ff37773d12b077">&#9670;&#160;</a></span>union_sets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::union_sets </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; char, char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Вспомогательная функция для объединения двух деревьев в структуре данных "дискретные множества". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Ссылка на словарь, в котором ключи - вершины, а значения - их родители. </td></tr>
    <tr><td class="paramname">u</td><td>Вершина, первая вершина для объединения. </td></tr>
    <tr><td class="paramname">v</td><td>Вершина, вторая вершина для объединения.</td></tr>
  </table>
  </dd>
</dl>
<p>Функция объединяет два дерева, содержащие вершины u и v, в одно дерево, используя их корневые вершины. Для этого сначала находим корневые вершины для u и v, затем делаем одно дерево поддеревом другого, устанавливая родительскую вершину одной из корневых вершин равной другой корневой вершине.</p>
<dl class="section user"><dt>Пример использования:</dt><dd><div class="fragment"><div class="line">std::map&lt;char, char&gt; parent;</div>
<div class="line">parent[<span class="charliteral">&#39;A&#39;</span>] = <span class="charliteral">&#39;A&#39;</span>;</div>
<div class="line">parent[<span class="charliteral">&#39;B&#39;</span>] = <span class="charliteral">&#39;A&#39;</span>;</div>
<div class="line">parent[<span class="charliteral">&#39;C&#39;</span>] = <span class="charliteral">&#39;C&#39;</span>;</div>
<div class="line"><a class="code hl_function" href="#a7a5b0e175d30fd3d24ff37773d12b077">union_sets</a>(parent, <span class="charliteral">&#39;B&#39;</span>, <span class="charliteral">&#39;C&#39;</span>); <span class="comment">// Теперь &#39;C&#39; будет поддеревом &#39;A&#39;</span></div>
<div class="ttc" id="aclass_graph_html_a7a5b0e175d30fd3d24ff37773d12b077"><div class="ttname"><a href="#a7a5b0e175d30fd3d24ff37773d12b077">Graph::union_sets</a></div><div class="ttdeci">void union_sets(std::map&lt; char, char &gt; &amp;parent, char u, char v)</div><div class="ttdoc">Вспомогательная функция для объединения двух деревьев в структуре данных &quot;дискретные множества&quot;.</div><div class="ttdef"><b>Definition</b> Graph.cpp:742</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad3da3461fb89b317e0385aed2bb6cfda" title="Вспомогательная функция для поиска корневой вершины дерева в структуре данных &quot;дискретные множества&quot;.">find()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a144ebc130cd6e4b1e2546fc33e8a8d45" name="a144ebc130cd6e4b1e2546fc33e8a8d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144ebc130cd6e4b1e2546fc33e8a8d45">&#9670;&#160;</a></span>AppTestSuite</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class AppTestSuite</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d8eacc7949c8a7fe17497370f0f4586" name="a2d8eacc7949c8a7fe17497370f0f4586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8eacc7949c8a7fe17497370f0f4586">&#9670;&#160;</a></span>GraphTestAccessor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_graph_test_accessor.html">GraphTestAccessor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a758b2efa0ca767374ea2157d8d76fc65" name="a758b2efa0ca767374ea2157d8d76fc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758b2efa0ca767374ea2157d8d76fc65">&#9670;&#160;</a></span>GraphTestSuite</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class GraphTestSuite</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a83c213617bc448b021fcb3b7644a0969" name="a83c213617bc448b021fcb3b7644a0969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c213617bc448b021fcb3b7644a0969">&#9670;&#160;</a></span>adjacent_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;char, std::vector&lt;char&gt; &gt; Graph::adjacent_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Список смежности </p>

</div>
</div>
<a id="ac4755d1464ab2f02b8760d870e724743" name="ac4755d1464ab2f02b8760d870e724743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4755d1464ab2f02b8760d870e724743">&#9670;&#160;</a></span>adjacent_matrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;int&gt; &gt; Graph::adjacent_matrix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Матрица смежности </p>

</div>
</div>
<a id="a68773809bb43852a6dd4aaac15b6eea9" name="a68773809bb43852a6dd4aaac15b6eea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68773809bb43852a6dd4aaac15b6eea9">&#9670;&#160;</a></span>coords</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;char, std::pair&lt;int, int&gt; &gt; Graph::coords</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Координаты вершин </p>

</div>
</div>
<a id="a3fc3eaf4b4f0a0c4becde65bd7b76bd8" name="a3fc3eaf4b4f0a0c4becde65bd7b76bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc3eaf4b4f0a0c4becde65bd7b76bd8">&#9670;&#160;</a></span>ID_NEXT_TITLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::ID_NEXT_TITLE = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Номер следующей вершины для выбора </p>

</div>
</div>
<a id="aabdb84dfb6a0985f453cc3da65ba2770" name="aabdb84dfb6a0985f453cc3da65ba2770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabdb84dfb6a0985f453cc3da65ba2770">&#9670;&#160;</a></span>instance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> * Graph::instance = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Указатель на единственный экземпляр класса (singleton) </p>

</div>
</div>
<a id="aecd0824db923712f473603157339b97e" name="aecd0824db923712f473603157339b97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd0824db923712f473603157339b97e">&#9670;&#160;</a></span>nextWeight</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::nextWeight = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Вес следующего ребра </p>

</div>
</div>
<a id="a062427bc763104537a8b461737acc9bd" name="a062427bc763104537a8b461737acc9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062427bc763104537a8b461737acc9bd">&#9670;&#160;</a></span>printoutAlgorithm</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Graph::printoutAlgorithm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Строка для вывода результатов алгоритмов </p>

</div>
</div>
<a id="a10a582524d63df99928e6b1feee31a24" name="a10a582524d63df99928e6b1feee31a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a582524d63df99928e6b1feee31a24">&#9670;&#160;</a></span>TITLES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string Graph::TITLES = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Названия вершин </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Graph/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>src/Graph/<a class="el" href="_graph_8cpp.html">Graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
